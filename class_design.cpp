/*********************************************************************************************************************
 *
 * class_design.cpp
 *
 * Cpp_design_patterns
 * Ludovic Blache
 *
 *********************************************************************************************************************/

#include <cstdlib>
#include <iostream>
#include <algorithm>


struct Point
{
    double x;
    double y;
};


/*------------------------------------------------------------------------------------------------------------+
|                                                     WIDGET                                                  |
+-------------------------------------------------------------------------------------------------------------*/

#ifndef _WIDGET_H_
#define _WIDGET_H_

class Widget
{
    public:

        // default contructor (optionnal here)
        Widget()
            : m_size(0.0)
            , m_center{ 0.0, 0.0 } // list-initialization operator to assigne each element in Point
            , m_title("default widget") //use initializer list for class instance members to avoid unecesary copy operations
            
        {
            //std::cout << " Default constructor called" << std::endl;
        }

        // Constructor should be explicit if there is a single parameter (here the second one has default value)
        // to avoid constructor to be called by, e.g., Circle c=3.14
        explicit Widget(double _size, Point _center = Point{ 0.0, 0.0 }, std::string _title = "widget") //explicit since second param has default value
            : m_size(_size)
            , m_center{ _center }
            , m_title(_title)
        {
            //std::cout << " Constructor called" << std::endl;
        }

        // Copy constructor
        Widget(Widget const& _other )
            : m_size( _other.m_size )
            , m_center{ _other.m_center }
            , m_title(_other.m_title)
        {
            //std::cout << " Copy constructor called" << std::endl;
        }

        // Move constructor
        Widget(Widget&& _other )
            : m_size(_other.m_size)
            , m_center{ _other.m_center }
            , m_title(std::move(_other.m_title))
        {
            //std::cout << " Move constructor called" << std::endl;
        }

        // Copy assignment operator
        Widget& operator=(Widget const& _other)
        {
            m_size = _other.m_size;
            m_center = _other.m_center;
            m_title = _other.m_title;
            //std::cout << " Copy assignment operator called" << std::endl;
            return *this; 
        }

        // Move assignment operator
        Widget& operator=(Widget&& _other)
        {
            m_size = _other.m_size;
            m_center = _other.m_center;
            m_title = std::move(_other.m_title);
            //std::cout << " Move assignment operator called" << std::endl;
            return *this;
        }

        // Destructor 
        // Should always be virtual to make sure the destructor of derived classes is called
        virtual ~Widget()
        {
            //std::cout << " Destructor called" << std::endl;
        }

        Point center() const { return m_center; }
        double size() const { return m_size; }
        std::string title() const { return m_title; }

    protected:
   
        Point m_center;
        double m_size;
        std::string m_title;
};

#endif


/*------------------------------------------------------------------------------------------------------------+
|                                                   WIDGETOWNER                                               |
+-------------------------------------------------------------------------------------------------------------*/

#ifndef _WIDGETOWNER_H_
#define _WIDGETOWNER_H_

class WidgetOwner
{
    public:

        // Do not write any default contructor
        // If other constructors are implemented, the default constructor is not generated by compiler
        // This way we prevent any instance to be created except by one of the constructors defined below

        WidgetOwner(int _id, Widget* _widget)
        : m_id{ _id }
        {
            if (!_widget) 
            {
                throw std::invalid_argument("Given pointer must not be nullptr");
            }
            if (_widget != nullptr) {
                m_widget.reset(new Widget(*_widget));
                //m_widget = new Widget(*other.m_widget);
            }
        }

        virtual ~WidgetOwner() = default;

        WidgetOwner(WidgetOwner const& _other)
        : m_id{ _other.m_id }
        {
            if (_other.m_widget != nullptr) {
                m_widget.reset(new Widget(*_other.m_widget));
                //m_widget = new Widget(*other.m_widget);
            }
        }

        WidgetOwner& operator=(WidgetOwner const& _other)
        {
            m_id = _other.m_id;

            if (_other.m_widget != nullptr) {

                m_widget.reset(new Widget(*_other.m_widget));

                //*m_widget = *_other.m_widget;
                //m_widget = new Widget(*_other.m_widget);
            }

            return *this;
        }

        WidgetOwner(WidgetOwner&& _other)
        : m_id{ std::move(_other.m_id) }
        {
            if (_other.m_widget != nullptr) {
                m_widget.reset(new Widget(std::move(*_other.m_widget)));
            }
        }

        WidgetOwner& operator=(WidgetOwner&& _other)
        {
            m_id = std::move(_other.m_id);
            if (_other.m_widget != nullptr) {
                *m_widget = std::move(*_other.m_widget);
            }
            return *this;
        }


        int id() const { return m_id; }
        Widget* widget() { return m_widget.get(); }
        Widget const* widget() const { return m_widget.get(); }

    private:

        int m_id;
        std::unique_ptr<Widget> m_widget = nullptr; // always give nullptr as default value 
};

#endif


/*------------------------------------------------------------------------------------------------------------+
|                                                      MAIN                                                   |
+-------------------------------------------------------------------------------------------------------------*/

std::ostream& operator<<( std::ostream& _os, Widget& _w )
{
    _os << std::endl
        << "Title = " << _w.title() << "  "
        << "Center = ( " << _w.center().x << " , " << _w.center().y << " )  "
        << "Radius = " << _w.size() << "  "
        << std::endl;
   return _os;
}

int main()
{
    /*
   // Default constructor
   {
       Widget w{};
      std::cout << " Default widget: " << w << std::endl;
   }


   // Constructor with default param
   {
       Widget w( 4 );
       std::cout << " Custom widget: " << w << std::endl;
   }


   // Constructor
   {
       Widget w(3, Point{ 1,1 }, "myWidget");
       std::cout << "Custm widget: " << w << std::endl;
   }
   

   // Copy construction
   {
       Widget w1(3, Point{ 1,2 }, "widget1");
       Widget w2( w1 );
       std::cout << " Copied widget: " << w2 << std::endl;
   }

   // Coppy assignement
   {
       Widget w1(3, Point{ 1,2 }, "widget1");
       Widget w2(4, Point{ 1,2 }, "widget2");
       w2 = w1;
       std::cout << " Coppy assignement widget: " << w2 << std::endl;
   }

   // Move
   {
       Widget w1(3, Point{ 1,2 }, "widget1");
       Widget w2 = std::move(w1);
       std::cout << " Moved widget: " << w2 << std::endl;
   }

   // Move
   {
       Widget w1(3, Point{ 1,2 }, "widget1");
       Widget w2(4, Point{ 1,2 }, "widget2");
       w2 = std::move(w1);
       std::cout << " Moved widget: " << w2 << std::endl;
   }
   */

   //while(1)
   {
       //WidgetOwner wo; // does not compile
       //std::cout << " Default owned widget : " << *wo1.widget() << std::endl;

       //WidgetOwner wo2(1, new Widget(0, Point{ 1,2 }, "widget1")); //memory leak

       auto pW1 = std::make_shared<Widget>(1, Point{ 2,3 }, "widget1");
       std::shared_ptr<Widget> pW2(new Widget(2, Point{ 3,4 }, "widget2"));// Ok, but slightly less efficient.


       WidgetOwner wo1(2, pW1.get());
       pW1.reset();
       WidgetOwner wo2(2, pW2.get());
       pW2.reset();
       std::cout << " Owned widget1 : " << *wo1.widget() << std::endl;
       std::cout << " Owned widget2 : " << *wo2.widget() << std::endl;

       WidgetOwner woCopy(wo1);
       std::cout << " Owned widget : " << *woCopy.widget() << std::endl;

       woCopy = wo2;
       std::cout << " Owned widget : " << *woCopy.widget() << std::endl;

       WidgetOwner woMove(std::move(wo1));
       std::cout << " Owned widget : " << *woMove.widget() << std::endl;

       woCopy = std::move(wo2);
       std::cout << " Owned widget : " << *woCopy.widget() << std::endl;

   }


   return EXIT_SUCCESS;
}
